---
topic: "GoのChannel"
prompt_version: "1.0.0"
timestamp: "2025-07-11T13:51:49Z"
---

GoのChannelは **「メッセージを運ぶパイプ」** として理解するのが最も効果的です。

## 核心的な理解

Channelは単なるデータ交換の仕組みではなく、**ゴルーチン間の協調動作を実現する同期プリミティブ**です。「Don't communicate by sharing memory; share memory by communicating」というGo哲学の具現化そのものです。

## なぜChannelが存在するのか？

従来の並行プログラミングでは、複数のスレッドが同じメモリを共有し、ロックで保護していました。しかしこれは：
- **競合状態**を生みやすい
- **デッドロック**が発生しやすい
- **推論が困難**になる

Channelはこれらの問題を「**メッセージパッシング**」で解決します。データの所有権を明確に移転することで、安全な並行処理を実現するのです。

## 動作原理の本質

```go
// バッファなしChannel（同期的）
ch := make(chan int)
go func() {
    ch <- 42  // 送信側は受信側が準備できるまで待機
}()
value := <-ch  // 受信側は送信側が準備できるまで待機
```

バッファなしChannelは**ランデブー（待ち合わせ）**を実現します。送信者と受信者が同じタイミングで準備できた時のみデータが流れます。

```go
// バッファありChannel（非同期的）
ch := make(chan int, 3)
ch <- 1  // バッファに余裕があるので即座に完了
ch <- 2
ch <- 3
ch <- 4  // バッファが満杯なので、受信者が現れるまで待機
```

## 他の概念との関連

- **Unix パイプ**：`cmd1 | cmd2` のように、プロセス間でデータを流す
- **プロデューサー・コンシューマー**：生産者と消費者の処理速度の違いを吸収
- **アクター モデル**：メッセージ送信による協調動作
- **CSP（Communicating Sequential Processes）**：Goの並行モデルの理論的基盤

## 実践的な応用パターン

**1. ワーカープール**
```go
jobs := make(chan Job, 100)
results := make(chan Result, 100)

// 複数ワーカーが同じChannelから仕事を取得
for w := 1; w <= 3; w++ {
    go worker(w, jobs, results)
}
```

**2. 終了シグナル**
```go
done := make(chan bool)
go func() {
    // 長時間の処理
    done <- true
}()
<-done  // 処理完了を待機
```

**3. 選択的受信**
```go
select {
case msg1 := <-ch1:
    // ch1からメッセージ受信
case msg2 := <-ch2:
    // ch2からメッセージ受信
case <-time.After(1 * time.Second):
    // タイムアウト
}
```

## 記憶に残るポイント

- **Channel = パイプ**：水道管のようにデータが流れる
- **所有権の移転**：データを「渡す」ことで共有を避ける
- **同期の道具**：データ交換と同時にタイミングも制御
- **方向性がある**：送信専用(`chan<-`)、受信専用(`<-chan`)も可能

この理解があれば、Fan-in/Fan-out、Pipeline、Rate limiting など、様々な並行処理パターンを自然に組み合わせて新しい問題に対応できるようになります。
