---
---

Node.jsのシングルスレッドの本質を理解するには、 **「なぜコンピュータは同時に複数のことを処理できるのか？」** という根本的な問いから始めるのが最も効果的です。

### 核心となる仕組み：イベントループという「交通整理」

Node.jsは**1つのメインスレッドで実行される**のに、なぜ数千のリクエストを同時に処理できるのでしょうか？

答えは**イベントループ**にあります。これは「交通整理をする警察官」のような存在です：

1. **キューに並ぶタスク**：I/O操作（ファイル読み書き、DB接続など）が発生すると、それらは「待機列」に並びます
2. **非同期処理**：重い処理は別のシステム（OSのスレッドプール）に委託
3. **コールバック実行**：完了した処理から順番にメインスレッドに結果を戻す

```javascript
// この例で理解する
console.log('1'); // 即座に実行
setTimeout(() => console.log('2'), 0); // キューに追加
console.log('3'); // 即座に実行
// 結果: 1 → 3 → 2
```

### なぜこの設計なのか？

**CPU集約的タスク vs I/O集約的タスク**の違いが鍵です：

- **CPU集約的**：計算処理（暗号化、画像処理など）→ マルチスレッドが有効
- **I/O集約的**：ネットワーク、ファイル、DB操作 → **待機時間が大部分**

Web開発の90%はI/O集約的なので、Node.jsの「待っている間に他の仕事をする」アプローチが理想的なのです。

### 他の知識との関連

この仕組みは以下と本質的に同じです：
- **レストランの接客**：注文を受けて厨房に回し、その間に他の客の対応
- **JavaScriptのPromise/async-await**：同じイベントループを使用
- **ReactのuseEffect**：同じ非同期処理の概念
- **OS のシステムコール**：Node.jsが内部で活用している仕組み

### 応用できる判断基準

この理解があれば、以下の判断ができます：

**Node.jsが適している場面**：
- API サーバー、チャットアプリ、リアルタイム通信
- ファイル処理、データベース操作が中心

**Node.jsが不適切な場面**：
- 大量の数値計算、画像・動画処理
- CPUを長時間占有する処理

### 実践での「なぜ？」に答える

- **なぜ`setTimeout(fn, 0)`でも遅延する？** → イベントループの仕組み
- **なぜコールバック地獄が生まれる？** → 非同期処理の連鎖
- **なぜWorkerスレッドが必要？** → CPU集約的処理への対処
- **なぜクラスター化が有効？** → マルチコア活用のため

この「イベントループによる協調的マルチタスキング」という核心概念を理解すれば、Node.jsの特性だけでなく、現代のWebアプリケーション設計全般に応用できる思考の基盤が身につきます。
